# 功能规格说明：知识库客户端优化

**功能分支**: `001-kb-tanstack-refactor`
**创建日期**: 2025-10-18
**状态**: 草稿
**输入**: 用户描述："仔细阅读/Users/wei/Coding/rafa/docs/knowledge-base.md，帮我优化知识库功能模块，server部分已经基本完成，client部分要把/Users/wei/Coding/rafa/client/src/hooks/useKnowledgeBaseRPC.ts使用tanstack query重构，UI页面直接使用"

## 用户场景与测试 *(必填)*

### 用户故事 1 - 自动缓存的无缝数据管理 (优先级: P1)

用户可以查看和管理知识库，所有操作都能获得即时反馈。通过优化的数据层自动缓存服务器响应并更新 UI，无需手动干预。

**优先级理由**: 这是整个功能的基础。没有合适的数据管理层，所有其他功能都会失败。用户会体验到缓慢、无响应的界面，失去对应用的信任。

**独立测试**: 可以通过创建、查看、更新和删除知识库来完整测试。成功的标准是：已获取数据的 UI 即时更新，无闪烁或加载状态，且自动后台重新获取保持数据新鲜。

**验收场景**:

1. **假设** 用户查看知识库列表，**当** 列表首次加载时，**那么** 从服务器获取数据并缓存供后续查看
2. **假设** 用户之前查看过列表，**当** 他们导航回列表时，**那么** 缓存数据立即显示，同时在后台加载新数据
3. **假设** 用户创建新知识库，**当** 操作成功时，**那么** 新知识库立即出现在列表中，无需完整刷新页面
4. **假设** 用户更新知识库名称，**当** 操作成功时，**那么** 更新后的名称在所有视图（列表、详情页、侧边栏）中显示，无需手动刷新
5. **假设** 用户删除知识库，**当** 操作成功时，**那么** 知识库立即从所有视图中消失

---

### 用户故事 2 - 乐观更新提供即时反馈 (优先级: P1)

用户在收藏/取消收藏知识库或执行其他快速操作时获得即时视觉反馈，使界面感觉响应灵敏，即使在服务器确认操作之前。

**优先级理由**: 用户对性能的感知至关重要。即使服务器响应需要 300ms，用户也期望简单操作（如收藏项目）获得即时反馈。这极大地提升了感知性能和用户满意度。

**独立测试**: 可以通过快速收藏/取消收藏知识库来测试。成功的标准是：即使在模拟网络延迟的情况下，UI 也能立即变化（星标图标立即切换），如果服务器操作失败则自动回滚。

**验收场景**:

1. **假设** 用户查看未收藏的知识库，**当** 他们点击星标图标时，**那么** 图标在服务器确认前立即变为已收藏状态
2. **假设** 用户已乐观收藏知识库，**当** 服务器操作失败时，**那么** 星标图标恢复为未收藏状态并显示错误消息
3. **假设** 用户快速执行多个收藏/取消收藏操作，**当** 操作正在进行时，**那么** 每个操作按顺序排队处理，不会出现竞态条件
4. **假设** 用户在侧边栏收藏知识库，**当** 操作成功时，**那么** 收藏状态同时在侧边栏和详情视图中更新

---

### 用户故事 3 - 带进度跟踪的智能文件上传 (优先级: P2)

用户可以上传文件并获得实时进度指示和自动状态更新，UI 智能处理处理状态，并在上传完成后立即更新文件列表。

**优先级理由**: 文件上传是核心功能，但使用频率低于查看/管理知识库。然而，糟糕的上传 UX 会造成严重挫败感，因此重要但可以在基础数据管理之后实现。

**独立测试**: 可以通过上传各种文件类型和大小来测试。成功的标准是：流畅的进度指示、上传后文件立即出现在列表中、失败上传的适当错误处理。

**验收场景**:

1. **假设** 用户选择要上传的文件，**当** 上传开始时，**那么** 显示进度指示器，显示上传百分比
2. **假设** 文件上传正在进行，**当** 用户导航离开并返回时，**那么** 上传在后台继续
3. **假设** 文件上传成功，**当** 服务器处理文件时，**那么** 文件立即出现在列表中，状态为"处理中"，然后无需手动刷新更新为"已完成"状态
4. **假设** 文件上传失败，**当** 错误发生时，**那么** 显示包含具体失败原因的错误消息，失败的文件不会出现在列表中
5. **假设** 多个文件正在上传，**当** 某些成功某些失败时，**那么** 每个文件的状态独立跟踪

---

### 用户故事 4 - 后台数据同步 (优先级: P3)

用户在返回应用或数据变陈旧时自动接收更新的数据，确保他们始终使用当前信息，无需手动刷新操作。

**优先级理由**: 这是一个改善数据新鲜度的锦上添花功能。虽然对多用户场景很重要，但大多数用户单独工作，可以容忍略微陈旧的数据。可以在核心功能之后实现。

**独立测试**: 可以通过在两个浏览器窗口中打开应用，在一个窗口中修改数据，并验证另一个窗口自动更新来测试。成功的标准是：在指定间隔后或窗口重新获得焦点时自动后台重新获取。

**验收场景**:

1. **假设** 用户在后台打开应用，**当** 他们切换回应用窗口时，**那么** 数据在后台自动刷新
2. **假设** 数据已缓存超过 5 分钟，**当** 用户查看知识库时，**那么** 在显示缓存版本的同时获取新数据
3. **假设** 另一个用户修改了共享知识库，**当** 当前用户的数据变陈旧时，**那么** UI 在配置的刷新间隔内自动更新
4. **假设** 用户离线，**当** 他们查看缓存数据时，**那么** 显示缓存数据，并有指示器显示数据可能已过时

---

### 边缘情况

- 当用户尝试在另一个收藏/取消收藏操作待处理时收藏知识库会发生什么？
- 系统如何处理同一知识库的并发文件上传？
- 当服务器在乐观更新期间返回不一致的数据时会发生什么？
- 系统如何处理单个知识库中极大的文件列表（1000+ 个文件）？
- 当文件上传因网络断开而中断时会发生什么？
- 系统如何处理多个标签页同时修改同一知识库时的竞态条件？
- 当缓存数据与新的服务器数据冲突时会发生什么？

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系统必须提供使用 TanStack Query 的集中式数据层，处理所有知识库 API 调用
- **FR-002**: 系统必须自动缓存所有 API 响应，并使用适当的缓存失效策略
- **FR-003**: 系统必须为收藏/取消收藏操作实现乐观更新，失败时自动回滚
- **FR-004**: 系统必须在底层数据更改时跨所有组件更新 UI（侧边栏、列表、详情视图）
- **FR-005**: 系统必须在所有视图中一致处理加载状态（初始加载、后台刷新、变更操作）
- **FR-006**: 系统必须在操作失败时显示包含具体失败原因的错误消息
- **FR-007**: 系统必须防止多个组件同时请求相同数据时的重复 API 调用
- **FR-008**: 系统必须在窗口重新获得焦点时实现后台数据重新获取
- **FR-009**: 系统必须实现 stale-while-revalidate 模式以提高感知性能
- **FR-010**: 系统必须处理文件上传进度跟踪和实时状态更新
- **FR-011**: 系统必须在上传新文件时自动更新文件列表，无需手动刷新
- **FR-012**: 系统必须通过 Hono RPC 类型推断维护所有 API 操作的类型安全
- **FR-013**: 系统必须对变更操作进行排队以防止竞态条件
- **FR-014**: 系统必须为失败的操作提供指数退避的重试逻辑
- **FR-015**: 系统必须将所有直接钩子调用迁移到 TanStack Query 钩子，不改变 UI 行为

### 关键实体

- **查询键（Query Keys）**: 缓存数据的结构化标识符（例如 `['knowledgeBases']`、`['knowledgeBase', id]`、`['knowledgeBase', id, 'files']`），用于实现精确的缓存失效
- **查询客户端（Query Client）**: 中央缓存管理器，在组件间存储和同步所有服务器状态
- **乐观更新（Optimistic Update）**: 临时本地数据更改，在服务器操作待处理时立即显示，失败时自动回滚
- **变更（Mutation）**: 修改数据并触发缓存更新的服务器端操作（创建、更新、删除）
- **陈旧时间（Stale Time）**: 缓存数据被认为已过时并触发后台重新获取的持续时间
- **缓存时间（Cache Time）**: 在垃圾回收之前将未使用数据保留在缓存中的持续时间

## 成功标准 *(必填)*

### 可衡量的结果

- **SC-001**: 用户在后续访问时可以即时（50ms 以内）查看缓存的知识库列表
- **SC-002**: 收藏/取消收藏操作在服务器确认前 16ms 内（60fps 下 1 帧）提供视觉反馈
- **SC-003**: 文件上传在服务器响应完成后 100ms 内显示在列表中
- **SC-004**: 后台数据刷新完成，不会导致 UI 闪烁或中断用户交互
- **SC-005**: 当多个组件同时挂载时，对相同数据的重复 API 调用为零
- **SC-006**: 失败的操作在向用户显示错误前自动重试最多 3 次
- **SC-007**: 迁移后所有现有 UI 功能继续以相同方式工作（零回归错误）
- **SC-008**: 缓存失效导致所有视图中的依赖数据在 200ms 内刷新
- **SC-009**: 用户在 50ms 内看到陈旧的缓存数据，同时为超过 5 分钟的数据在后台加载新数据
- **SC-010**: 即使有 100+ 个并发文件上传，应用仍保持响应（UI 在 100ms 内响应）
